#include <Shared.fxh>

//--------------------------------------------------------------------------------------
// Pixel Shader
//--------------------------------------------------------------------------------------


// [ Hash 함수 ]
//  0~1 사이의 난수 값 반환
//  - dot()으로 좌표를 하나의 값으로 압축
//  - sin()과 큰 상수를 곱해 난수처럼 보이게 변형
//  - frac()으로 소수 부분만 남겨 0~1 범위로 제한
float Hash(float2 p)
{
    return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}


// [ Noise 함수 ]
//  uv 좌표를 넣으면 부드러운 변화하는 랜덤 값을 반환
//  - UV를 정수 그리드(i)와 그 안의 위치(f)로 분리
//  - 그리드 꼭짓점 4곳에서 Hash 난수값 가져오기 
//  - Smoothstep 보간으로 값의 급격한 변화를 제거
//  - Bilinear interpolation(양선형 보간법)으로 사각형 내부 값을 계산
float Noise(float2 uv)
{
    float2 i = floor(uv);   // 현재 좌표의 정수 부분 (그리드 위치)
    float2 f = frac(uv);    // 소수 부분 (그리드 내 위치, 0~1)
    
    float a = Hash(i);                  // 왼쪽 아래
    float b = Hash(i + float2(1, 0));   // 오른쪽 아래
    float c = Hash(i + float2(0, 1));   // 왼쪽 위
    float d = Hash(i + float2(1, 1));   // 오른쪽 위
    
    float2 u = f * f * (3.0 - 2.0 * f); // Smoothstep 보간값 계산

    // bilinear interpolation (사각형 내부를 부드럽게 보간)
    // bilinear interpolation : linear interpolation을 x축과 y축으로 두 번 적용하여 값을 유추하는 방법
    float lerp_x0 = lerp(a, b, u.x);        // 아래쪽
    float lerp_x1 = lerp(c, d, u.x);        // 위쪽
    
    return lerp(lerp_x0, lerp_x1, u.y);     // 위아래 보간 -> 최종 값
}


// [ FBM (Fractional Brownian Motion) : 여러 레이어의 Noise 합성 ]
//  입력 좌표 uv에 대해 여러 주파수/진폭의 노이즈를 합쳐 자연스러운 패턴 생성
float FBM(float2 uv)
{
    float value = 0.0;      // 최종 fbm 값
    float amplitude = 0.5;  // 초기 진폭
    float frequency = 1.0;  // 초기 주파수

    // 여러 옥타브(Noise 레이어)를 합성
    for (int i = 0; i < 4; i++)
    {
        value += amplitude * Noise(uv * frequency); // 각 레이어 Noise 합치기
        frequency *= 2.0; // 다음 레이어는 주파수를 2배로 -> 더 세밀한 패턴
        amplitude *= 0.5; // 진폭은 반으로 줄여서 영향력 감소
    }
    return value;
}


float4 main(PS_INPUT input) : SV_TARGET
{ 
    
    float2 uv = input.uv; // 현재 픽셀의 UV 좌표 (0~1 범위) : 화면에서 이 픽셀이 어디 위치하는지를 나타냄
    

    //=====================================================================
    // 1. 기본 흐름 (전체가 위로 이동하는 큰 움직임)
    //=====================================================================
    // - advectedUV: 연기가 시간에 따라 이동한 위치
    
    float2 flowDir = float2(0.0, -1.0);             // 위쪽 : Y 방향 음수(-)
    float2 advectedUV = uv + flowDir * time * 0.1;  // time 에 따라 UV를 위쪽으로 이동

    

    //=====================================================================
    // 2. 큰 흐름 (연기 덩어리 단위의 느린 흔들림) , 주파수: 0.6 
    //=====================================================================
    // - largeWarp: 연기 전체가 좌우로 휘어지는 "큰 흐름" 역할
    
    float2 largeWarp = float2(
    FBM(advectedUV * 0.6 + time * 0.05), // X 방향 왜곡
    FBM(advectedUV * 0.6 - time * 0.05)  // Y 방향 왜곡
    );

    

    //=====================================================================
    // 3. 작은 난류 (연기 표면의 잔잔한 요동) , 주파수: 2.0
    //=====================================================================
    // - smallWarp: 연기 표면의 미세하게 끓는 듯한 느낌
    
    float2 smallWarp = float2(
    FBM(advectedUV * 2.0 + time * 0.2),
    FBM(advectedUV * 2.0 - time * 0.2)
    );

    

    //=====================================================================
    // 4. Domain Warping (큰 흐름 + 작은 난류 합성)
    //=====================================================================
    // - warp: UV 좌표를 얼마나 왜곡할지 결정하는 값
    
    // 큰 흐름은 강하게, 작은 난류는 약하게 섞기
    // -> 전체적인 방향성 유지하면서 자연스러운 디테일 추가 
    
    float2 warp = largeWarp * 1.2 + smallWarp * 0.4;

    

    //=====================================================================
    // 5. 왜곡된 UV로 연기 밀도 계산
    //=====================================================================
    // - density: 값이 클수록 연기가 진하고, 작을수록 연기가 옅음
    
    // 왜곡된 좌표에 FBM을 다시 적용: 연기의 진하고 옅은 부분(밀도) 생성
    float density = FBM(advectedUV + warp);



    //=====================================================================
    // 6. 위로 갈수록 연기가 사라지는 효과 (높이에 따른 밀도 감쇠)
    //=====================================================================

    // 약간의 노이즈를 섞어서 위쪽이 균일하게 사라지지 않도록 함
    float fadeNoise = FBM(uv * 1.5);

    // uv.y가 커질수록(위로 갈수록) 값이 줄어듦 -> smoothstep으로 부드러운 감쇠 곡선 생성
    float heightFade = smoothstep(1.0, 0.2, uv.y + fadeNoise * 0.1);

    // 최종 밀도에 높이 감쇠 적용
    density *= heightFade;

    
    
    //=====================================================================
    // 7. 최종 색상 출력
    //=====================================================================

    // RGB는 연기 색상 (연한 회색)
    // Alpha는 연기 밀도 -> 진할수록 불투명
    float4 smokeColor = float4(0.8, 0.8, 0.8, density);

    
    return smokeColor;
}
